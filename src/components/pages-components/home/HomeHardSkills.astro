---
import useLang from "@utils/useLang";
import { hardSkills, hardSkillsGroup } from "@consts/skills";

const { t } = useLang(Astro.url);
---

<section class="w-full h-vh">
  <div
    class="sm:max-w-7xl mx-auto px-6 sm:px-10 xl:px-0 py-10 grid grid-cols-1 gap-7"
  >
    <h4 class="text-3xl font-bold text-center">{t("skills.title")}</h4>
    <p class="text-center text-2 sm:w-4/4 md:w-3/4 lg:w-2/4 mx-auto">
      {t("skills.description")}
    </p>

    <div
      class="grid grid-cols-1fr lg:grid-cols-[1fr_minmax(200px,0.5fr)] gap-3"
    >
      <div class="tech-matrix" data-tech-grid>
        {
          hardSkills.map((skill, index) => {
            const row = Math.floor(index / 5) + 1;
            const column = (index % 5) + 1;

            return (
              <div
                class="tech-cell flex bg-3 size-20 items-center justify-center rounded-sm"
                data-tech-cell
                data-row={row}
                data-col={column}
                aria-label={skill.title}
              >
                <skill.icon class="size-12" />
              </div>
            );
          })
        }
      </div>

      <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-1 gap-3">
        {
          hardSkillsGroup.map((skill) => (
            <div class="flex flex-col gap-3 bg-3 p-6 rounded-sm">
              <div class="flex items-center gap-2">
                <skill.icon class="size-5" />
                <h6 class="text-md font-bold">{t(skill.titleKey)}</h6>
              </div>
              <p class="text-sm">{t(skill.descriptionKey)}</p>
            </div>
          ))
        }
      </div>
    </div>
  </div>
</section>

<style is:inline>
  .tech-matrix {
    display: grid;
    grid-template-columns: repeat(5, minmax(0, 1fr));
    grid-template-rows: repeat(3, minmax(0, 1fr));
    gap: 1rem;
    overflow: hidden;
  }

  .tech-cell svg {
    width: 3rem;
    height: 3rem;
  }

  .tech-cell {
    will-change: transform;
  }

  @media (max-width: 640px) {
    .tech-matrix {
      gap: 0.75rem;
    }
  }
</style>

<script>
  const initHardSkillsCarousel = () => {
    const grid = document.querySelector("[data-tech-grid]");
    if (!grid || grid.dataset.carouselInit === "true") return;
    grid.dataset.carouselInit = "true";

    const prefersReducedMotion = window.matchMedia(
      "(prefers-reduced-motion: reduce)",
    ).matches;
    if (prefersReducedMotion) return;

    const stepMs = 2600;
    const animationMs = 700;
    const columns = 5;
    const rows = 3;
    let isAnimating = false;

    const getCells = () => Array.from(grid.children);

    const capturePositions = () => {
      const positions = new Map();
      for (const cell of getCells()) {
        positions.set(cell, cell.getBoundingClientRect());
      }
      return positions;
    };

    const applyFlip = (firstPositions) => {
      const lastPositions = new Map();
      for (const cell of getCells()) {
        lastPositions.set(cell, cell.getBoundingClientRect());
      }

      for (const cell of getCells()) {
        const firstRect = firstPositions.get(cell);
        const lastRect = lastPositions.get(cell);
        if (!firstRect || !lastRect) continue;

        const dx = firstRect.left - lastRect.left;
        const dy = firstRect.top - lastRect.top;
        if (dx === 0 && dy === 0) continue;

        cell.style.transition = "transform 0s";
        cell.style.transform = `translate(${dx}px, ${dy}px)`;
      }

      requestAnimationFrame(() => {
        for (const cell of getCells()) {
          cell.style.transition = `transform ${animationMs}ms ease`;
          cell.style.transform = "translate(0, 0)";
        }
      });
    };

    const step = () => {
      if (isAnimating) return;
      isAnimating = true;

      const firstPositions = capturePositions();
      const cells = getCells();
      if (cells.length === 0) return;

      const rowSize = columns;
      const totalRows = Math.min(rows, Math.ceil(cells.length / rowSize));
      const rowDirections = ["left", "right", "left"];
      const rowCells = [];
      const outgoing = [];

      for (let rowIndex = 0; rowIndex < totalRows; rowIndex += 1) {
        const start = rowIndex * rowSize;
        const currentRow = cells.slice(start, start + rowSize);
        rowCells.push(currentRow);

        const direction = rowDirections[rowIndex] ?? "left";
        if (currentRow.length === 0) {
          outgoing.push(null);
          continue;
        }
        outgoing.push(
          direction === "left"
            ? currentRow[0]
            : currentRow[currentRow.length - 1],
        );
      }

      const incoming = [];
      incoming[0] = outgoing[1] ?? null;
      incoming[1] = outgoing[2] ?? null;
      incoming[2] = outgoing[0] ?? null;

      const reordered = [];
      for (let rowIndex = 0; rowIndex < totalRows; rowIndex += 1) {
        const currentRow = rowCells[rowIndex] ?? [];
        const direction = rowDirections[rowIndex] ?? "left";
        const incomingItem = incoming[rowIndex];

        if (currentRow.length === 0) continue;

        if (direction === "left") {
          reordered.push(...currentRow.slice(1), incomingItem ?? currentRow[0]);
        } else {
          reordered.push(
            incomingItem ?? currentRow[currentRow.length - 1],
            ...currentRow.slice(0, -1),
          );
        }
      }

      for (let i = totalRows * rowSize; i < cells.length; i += 1) {
        reordered.push(cells[i]);
      }

      for (const cell of reordered) {
        grid.appendChild(cell);
      }
      applyFlip(firstPositions);

      window.setTimeout(() => {
        isAnimating = false;
      }, animationMs);
    };

    const intervalId = window.setInterval(step, stepMs);
    grid.dataset.carouselIntervalId = String(intervalId);
  };

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initHardSkillsCarousel);
  } else {
    initHardSkillsCarousel();
  }

  document.addEventListener("astro:page-load", initHardSkillsCarousel);
</script>
